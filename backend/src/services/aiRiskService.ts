import { GoogleGenerativeAI } from '@google/generative-ai';
import { RiskDecision } from '../types/user';

interface RiskAssessmentResult {
  riskScore: number;
  decision: RiskDecision;
  reasoning: string;
  confidence: number;
}

interface UserData {
  email: string;
  name: string;
  createdAt: Date;
}

/**
 * Production-ready AI Risk Assessment Service
 * Deterministic signals + AI explanation
 */
export class AIRiskService {
  private genAI: GoogleGenerativeAI | null = null;
  private useMock: boolean = false;

  constructor() {
    const apiKey = process.env.GEMINI_API_KEY;

    if (apiKey) {
      try {
        this.genAI = new GoogleGenerativeAI(apiKey);
        console.log('‚úÖ AI Risk Service: Google Gemini API initialized');
      } catch {
        console.warn('‚ö†Ô∏è AI Risk Service: Failed to initialize Gemini, using mock mode');
        this.useMock = true;
      }
    } else {
      console.warn('‚ö†Ô∏è AI Risk Service: GEMINI_API_KEY not found, using mock mode');
      this.useMock = true;
    }
  }

  async assessRisk(userData: UserData): Promise<RiskAssessmentResult> {
    // üîπ Deterministic signals FIRST
    const signals = this.computeRiskSignals(userData);

    // If clearly risky, skip AI decision
    if (signals.forceFlag) {
      return {
        riskScore: signals.riskScore,
        decision: RiskDecision.FLAG,
        reasoning: signals.reasoning,
        confidence: 0.9,
      };
    }

    if (this.useMock || !this.genAI) {
      return this.mockAssessment(userData, signals);
    }

    try {
      return await this.realAIAssessment(userData, signals);
    } catch (error) {
      console.warn('AI failed, falling back to mock assessment');
      return this.mockAssessment(userData, signals);
    }
  }

  /**
   * üî• NEW: Deterministic risk signal engine
   */
  private computeRiskSignals(userData: UserData) {
    const email = userData.email.toLowerCase();
    const [localPart, domain] = email.split('@');

    const disposableDomains = [
      'tempmail',
      'guerrillamail',
      '10minutemail',
      'mailinator',
      'yopmail',
    ];

    const isDisposableDomain = disposableDomains.some(d =>
      domain.includes(d)
    );

    const isAutoGeneratedLocalPart =
      localPart.length >= 15 &&
      /^[a-z0-9]+$/.test(localPart) &&
      !localPart.includes('.') &&
      !localPart.includes('_');

    let riskScore = 0.2;
    let reasoning = 'Low risk: No major risk indicators detected';
    let forceFlag = false;

    if (isDisposableDomain) {
      riskScore += 0.6;
      reasoning = 'Flagged: Disposable email domain detected';
      forceFlag = true;
    } else if (isAutoGeneratedLocalPart) {
      riskScore += 0.4;
      reasoning = 'Flagged: Auto-generated email pattern detected';
      forceFlag = true;
    }

    return {
      isDisposableDomain,
      isAutoGeneratedLocalPart,
      riskScore: Math.min(1, riskScore),
      reasoning,
      forceFlag,
    };
  }

  /**
   * Real AI assessment ‚Üí AI EXPLAINS, does not decide blindly
   */
  private async realAIAssessment(
    userData: UserData,
    signals: ReturnType<AIRiskService['computeRiskSignals']>
  ): Promise<RiskAssessmentResult> {
    const model = this.genAI!.getGenerativeModel({
      model: process.env.GEMINI_MODEL || 'gemini-1.5-flash',
    });

    const prompt = `
You are a backend fraud analysis system.

User Email: ${userData.email}
User Name: ${userData.name}

Detected Signals:
- Disposable domain: ${signals.isDisposableDomain}
- Auto-generated local-part: ${signals.isAutoGeneratedLocalPart}

Rules:
- If auto-generated local-part OR disposable domain ‚Üí FLAG
- Do NOT invent new signals
- Explain based only on detected signals

Respond ONLY in JSON:
{
  "riskScore": number,
  "decision": "ALLOW" | "FLAG",
  "reasoning": string,
  "confidence": number
}
`;

    const result = await model.generateContent(prompt);
    const text = result.response.text().trim();
    const json = JSON.parse(text.match(/\{[\s\S]*\}/)![0]);

    return {
      riskScore: json.riskScore,
      decision: json.decision === 'FLAG' ? RiskDecision.FLAG : RiskDecision.ALLOW,
      reasoning: json.reasoning,
      confidence: json.confidence,
    };
  }

  /**
   * Mock assessment using same deterministic signals
   */
  private mockAssessment(
    userData: UserData,
    signals: ReturnType<AIRiskService['computeRiskSignals']>
  ): RiskAssessmentResult {
    return {
      riskScore: signals.riskScore,
      decision: signals.forceFlag ? RiskDecision.FLAG : RiskDecision.ALLOW,
      reasoning: signals.reasoning,
      confidence: 0.75,
    };
  }
}

// Singleton
export const aiRiskService = new AIRiskService();
